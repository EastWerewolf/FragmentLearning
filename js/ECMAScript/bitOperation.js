/**
 * 位运算 AND
 * 位运算 AND 由和号（&）表示，直接对数字的二进制形式进行运算。
 * 它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行 AND 运算
 * 1&1=1 1&0=0 0&1=0 0&0=0
 */
let iResult = 25 & 3;
console.log(iResult);	//输出 "1"
//25 和 3 进行 AND 运算的结果是 1。为什么？分析如下：
//25 = 0000 0000 0000 0000 0000 0000 0001 1001
//3 = 0000 0000 0000 0000 0000 0000 0000 0011
//---------------------------------------------
//  AND = 0000 0000 0000 0000 0000 0000 0000 0001

/**
 * 位运算 OR
 * 位运算 OR 由符号（|）表示，也是直接对数字的二进制形式进行运算。
 * 在计算每位时，OR 运算符采用下列规则
 * 1|1=1 1|0=1 0|1=1 0|0=0;
 */
let iResult1 = 25 | 3;
console.log(iResult1);	//输出 "27"
//25 = 0000 0000 0000 0000 0000 0000 0001 1001
//3 = 0000 0000 0000 0000 0000 0000 0000 0011
//--------------------------------------------
//OR = 0000 0000 0000 0000 0000 0000 0001 1011
//可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11011 等于 27

/**
 * 位运算 XOR
 * 位运算 XOR 由符号（^）表示，当然，也是直接对二进制形式进行运算。
 * XOR 不同于 OR，当只有一个数位存放的是 1 时，它才返回 1。真值表如下：
 * 1^1=0 1^0=1 0^1=1 0^0=0
 */
let iResult2 = 25 ^ 3;
console.log(iResult2);	//输出 "26"
//25 = 0000 0000 0000 0000 0000 0000 0001 1001
//3 = 0000 0000 0000 0000 0000 0000 0000 0011
//---------------------------------------------
//XOR = 0000 0000 0000 0000 0000 0000 0001 1010

/**
 * 左移运算
 * 左移运算由两个小于号表示（<<）。它把数字中的所有数位向左移动指定的数量。
 * 例如，把数字 2（等于二进制中的 10）左移 5 位，空位用0 填充
 * 结果为 64（等于二进制中的 1000000）
 */
let iOld = 2;		//等于二进制 10
let iNew = iOld << 5;	//等于二进制 1000000 十进制 64
console.log(iNew); //输出64

/**
 * 有符号右移运算
 * 有符号右移运算符由两个大于号表示（>>）。
 * 它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。
 * 移动数位后会造成空位。这次，空位位于数字的左侧，但位于符号位之后。ECMAScript 用符号位的值填充这些空位，创建完整的数字
 * 有符号右移运算符恰好与左移运算相反
 */
let iOld1 = 64;		//等于二进制 1000000
let iNew1 = iOld1 >> 5;	//等于二进制 10 十进制 2
console.log(iNew1);//输出2
/**
 * 无符号右移运算
 * 无符号右移运算用 0 填充所有空位。对于正数，这与有符号右移运算的操作一样，而负数则被作为正数来处理。
 * 由于无符号右移运算的结果是一个 32 位的正数，所以负数的无符号右移运算得到的总是一个非常大的数字。
 * 例如，如果把 -64 右移 5 位，将得到 134217726
 */

/*
* ~运算符NOT
* 把运算数转换成 32 位数字
* 把二进制数转换成它的二进制反码
* 把二进制数转换成浮点数
* 位运算 NOT 实质上是对数字求负，然后减 1
*/
let iNum11 = 25;		//25 等于 00000000000000000000000000011001
iNum11 = ~iNum11;	//转换为 11111111111111111111111111100110
console.log(iNum11);//输出 -26
let iNum12 = '20';
iNum12 = ~iNum12;
console.log(iNum12);//输出-21;
let iNum13 = 'abc';
iNum13 = ~iNum13;
console.log(iNum13);//输出-1;
console.log(~true);//输出-2;
console.log(~false);//输出-1;
console.log(~undefined);//输出-1
/*
* ~~ 运算符
* 就是讲变量转化成Number(数字)类型
*/
let a='123';
console.log(~~a); //输出123
let b='asd';
console.log(~~b); //输出0
let c=1===1;
console.log(~~c);//输出1
let e=undefined;
console.log(~~e);//输出0
let f=!undefined;
console.log(~~f);//输出1

/*
* 前增量/前减量运算符 ++123/--123
* 后增量/后减量运算符 123++/123--
*/
let iNum = 10;
++iNum;
console.log(iNum); //输出11
//上面的代码等价于
let iNum1 = 10;
iNum1 = iNum1 + 1;
//同样 前减量也是一样
let iNum2 = 10;
--iNum2;
console.log(iNum2)//输出9
//后增量/后减量运算符 与上面的有所不同
//与前缀式运算符不同的是，后缀式运算符是在计算过包含它们的表达式后才进行增量或减量运算的
let iNum3 = 10;
iNum3++;//此时iNum3还是10
console.log(iNum3);//输出11
let iNum4 = 10;
iNum4--;//此时iNum4还是10
console.log(iNum4);//输出9

/*
* 一元加法和一元减法
* 一元加法本质对数字无任何影响 会把字符串转换成数字
* 一元减法运算符也会把字符串转换成近似的数字，此外还会对该值求负
* 无法转成数字的字符串会被转化成NaN
*/
let iNum5 = 20;
iNum5 = +iNum5;
console.log(iNum5);//输出20
let iNum6 = '20';
console.log(typeof iNum6);//输出'string'
console.log(typeof +iNum6);//输出'number'
let iNum7 = '20';
iNum7 = - iNum7;
console.log(iNum7);//输出-20
let iNum8 = 'abc';
iNum8 = + iNum8;
console.log(iNum8);//输出NaN
iNum8 = - iNum8;
console.log(iNum8);//输出NaN



